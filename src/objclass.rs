// automatically generated by rust-bindgen
#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
extern crate libc;

pub type cls_handle_t = *mut ::std::os::raw::c_void;
pub type cls_method_handle_t = *mut ::std::os::raw::c_void;
pub type cls_method_context_t = *mut ::std::os::raw::c_void;
pub type cls_method_call_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: cls_method_context_t,
                                                 indata: *mut ::std::os::raw::c_char,
                                                 datalen: ::std::os::raw::c_int,
                                                 outdata: *mut *mut ::std::os::raw::c_char,
                                                 outdatalen: *mut ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct cls_deps_t {
    pub name: *const ::std::os::raw::c_char,
    pub ver: *const ::std::os::raw::c_char,
}
impl ::std::default::Default for cls_deps_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cls_trigger_t = ::std::os::raw::c_int;
extern "C" {
    pub fn __cls_init();
    pub fn cls_log(level: ::std::os::raw::c_int,
                   format: *const ::std::os::raw::c_char,
                   ...)
                   -> ::std::os::raw::c_int;

    pub fn cls_alloc(size: usize);

    pub fn cls_free(p: *mut ::std::os::raw::c_void);
    pub fn cls_read(hctx: cls_method_context_t,
                    ofs: ::std::os::raw::c_int,
                    len: ::std::os::raw::c_int,
                    outdata: *mut *mut ::std::os::raw::c_char,
                    outdatalen: *mut ::std::os::raw::c_int)
                    -> ::std::os::raw::c_int;
    pub fn cls_call(hctx: cls_method_context_t,
                    cls: *const ::std::os::raw::c_char,
                    method: *const ::std::os::raw::c_char,
                    indata: *mut ::std::os::raw::c_char,
                    datalen: ::std::os::raw::c_int,
                    outdata: *mut *mut ::std::os::raw::c_char,
                    outdatalen: *mut ::std::os::raw::c_int)
                    -> ::std::os::raw::c_int;
    pub fn cls_getxattr(hctx: cls_method_context_t,
                        name: *const ::std::os::raw::c_char,
                        outdata: *mut *mut ::std::os::raw::c_char,
                        outdatalen: *mut ::std::os::raw::c_int)
                        -> ::std::os::raw::c_int;
    pub fn cls_setxattr(hctx: cls_method_context_t,
                        name: *const ::std::os::raw::c_char,
                        value: *const ::std::os::raw::c_char,
                        val_len: ::std::os::raw::c_int)
                        -> ::std::os::raw::c_int;
    // See: https://users.rust-lang.org/t/how-to-implement-a-c-union-in-rust/3291/4
    // and https://github.com/rust-lang/rust/issues/877
    // pub fn cls_get_request_origin(hctx: cls_method_context_t,
    // origin: *mut entity_inst_t) -> ::std::os::raw::c_int;
    //

    pub fn cls_register(name: *const ::std::os::raw::c_char,
                        handle: *mut cls_handle_t)
                        -> ::std::os::raw::c_int;
    pub fn cls_unregister(arg1: cls_handle_t) -> ::std::os::raw::c_int;
    pub fn cls_register_method(hclass: cls_handle_t,
                               method: *const ::std::os::raw::c_char,
                               flags: ::std::os::raw::c_int,
                               class_call: cls_method_call_t,
                               handle: *mut cls_method_handle_t)
                               -> ::std::os::raw::c_int;
    pub fn cls_unregister_method(handle: cls_method_handle_t) -> ::std::os::raw::c_int;
    pub fn cls_link(handle: cls_method_handle_t,
                    priority: ::std::os::raw::c_int,
                    trigger: cls_trigger_t)
                    -> ::std::os::raw::c_int;
    pub fn cls_unlink(handle: cls_method_handle_t) -> ::std::os::raw::c_int;
    pub fn class_init();
    pub fn class_fini();
}
